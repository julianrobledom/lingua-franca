/**
 * This example creates a Protocol Buffer message and passes it to another reactor without packing
 * and unpacking. This demonstrates that local communication, within one shared-memory machine, need
 * not incur the overhead of packing and unpacking.
 *
 * To run this example first install the protocol buffers compiler from
 * https://github.com/protocolbuffers/protobuf. It is also available from homebrew on a Mac via
 *
 * $ brew install protobuf
 *
 * Building protobuf from source is slow, so avoid doing that if possible. Next install the C plugin
 * for protocol buffers from
 *
 * https://github.com/protobuf-c/protobuf-c
 *
 * The code generator assumes that executables are installed within the PATH. On a Mac, this is
 * typically at /usr/local/bin.
 */
target C {
  protobufs: [Hello.proto],
  timeout: 1 s
}

reactor BaseProto {
  preamble {=
    // FIXME: Ideally, these functions would be generated by the tool
    // processing the .proto file.
    #include <string.h>
    
    Hello* hello_constructor(char* name, int32_t number) {
      Hello* result = (Hello*)malloc(sizeof(Hello));
      hello__init(result);
      // Copy the string into dynamically allocated memory.
      char* name_copy = (char*)malloc(strlen(name) + 1);
      if (name_copy == NULL) lf_print_error_and_exit("Out of memory.");
      strcpy(name_copy, name);
      result->name = name_copy;
      result->number = number;
      return result;
    }
    // Destructor as required by
    // https://www.lf-lang.org/docs/handbook/target-language-details?target=c#dynamically-allocated-data
    // This destructor is to be used if the Hello object is constructed using the hello_constructor
    // or the copy constructor.
    // If the Hello object is unpacked (i.e. at the receiving end), then it should be freed with
    // hello_unpacked_destructor().
    void hello_destructor(void* hello) {
      Hello* cast = (Hello*)hello;
      free(cast->name);
      free(cast);
    }
    // Destructor to use at the receiving end, which frees the memory used to unpack the message.
    void hello_unpacked_destructor(void* hello) {
      Hello* cast = (Hello*)hello;
      hello__free_unpacked(cast, NULL);
    }
    // FIXME: Should also provide a copy constructor.
  =}
}

reactor SourceProto extends BaseProto {
  output out: Hello*

  reaction(startup) -> out {=
    // The output port needs to be associated with a destructor to
    // free the memory we are allocating here.
    // See https://github.com/lf-lang/lingua-franca/issues/2121
    lf_set_destructor(out, hello_destructor);
    // Don't really need a copy constructor here because it will not be used.
    Hello* value = hello_constructor("Hello World", 42);
    lf_set(out, value);
  =}
}

reactor SinkProto extends BaseProto {
  input in: Hello*

  reaction(startup) in {=
    // FIXME: Ideally, this would be automatically generated.
    lf_set_destructor(in, hello_unpacked_destructor);
  =}
  reaction(in) {=
    printf("Received: name=\"%s\", number=%d.\n", in->value->name, in->value->number);
  =}
}

federated reactor {
  s = new SourceProto()
  d = new SinkProto()
  s.out -> d.in serializer "proto"
}
