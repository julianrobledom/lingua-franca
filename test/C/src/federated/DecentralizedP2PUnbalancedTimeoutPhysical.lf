/**
 * Test a source-destination scenario where the source falls behind real-time, and reaches the
 * timeout much later than the destination. In this test, the destination closes the connection
 * early, causing the transmission to fail. Warnings will be printed.
 *
 * The test fails if the federation does not exit amenably. This variant has a physical connection
 * between source and destination.
 */
target C {
  timeout: 10 msec,
  coordination: decentralized
}

reactor Clock(offset: time = 0, period: time = 1 sec) {
  output y: int
  timer t(offset, period)
  state count: int = 0

  reaction(t) -> y {=
    (self->count)++;
    //printf("Reacting at time %ld.\n", lf_time_logical_elapsed());
    lf_set(y, self->count);
  =}

  reaction(shutdown) {=
    lf_print("SUCCESS: the source exited successfully.");
  =}
}

reactor Destination(STP_offset: time = 10 ms) {
  input x: int
  state s: int = 1

  reaction(x) {=
    lf_print("Received %d", x->value);
    if (x->value != self->s) {
      lf_print_error_and_exit("Expected %d and got %d.", self->s, x->value);
    }
    self->s++;
  =} STP(10 ms) {=
    lf_print_error_and_exit("***** STP Violation. This should not occur with a physical connection");
  =}

  reaction(shutdown) {=
    lf_print("**** shutdown reaction invoked.");
    lf_print("Approx. time per reaction: %lld ns for %d reactions",
        lf_time_physical_elapsed()/(self->s), self->s - 1
    );
  =}
}

federated reactor(period: time = 100 usec) {
  c = new Clock(period=period)
  d = new Destination()
  c.y ~> d.x
}
